{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup NextJS Project with TailwindCSS and ShadUI",
        "description": "Initialize the project with NextJS App Directory structure, configure TailwindCSS for styling, and integrate ShadUI for reusable components.",
        "details": "1. Create a new NextJS project using `npx create-next-app@latest` with the App Directory option enabled\n2. Install TailwindCSS: `npm install -D tailwindcss postcss autoprefixer`\n3. Initialize TailwindCSS: `npx tailwindcss init -p`\n4. Configure TailwindCSS in tailwind.config.js to include app paths\n5. Install ShadUI: `npm install @shadcn/ui`\n6. Initialize ShadUI: `npx shadcn-ui@latest init`\n7. Set up basic folder structure:\n   - app/\n   - components/\n   - lib/\n   - styles/\n8. Create global CSS file with TailwindCSS directives\n9. Set up environment variables structure (.env.local)",
        "testStrategy": "1. Verify NextJS dev server starts without errors\n2. Confirm TailwindCSS styles are applied correctly\n3. Test that ShadUI components render properly\n4. Ensure App Directory routing works as expected\n5. Validate environment variables are accessible",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NextJS Project with App Directory",
            "description": "Initialize a new NextJS project with the App Directory structure enabled and set up the basic folder structure.",
            "dependencies": [],
            "details": "Run `npx create-next-app@latest` with the App Directory option enabled. Set up the basic folder structure including app/, components/, lib/, and styles/ directories. Create a .env.local file for environment variables.\n<info added on 2025-08-23T05:17:09.909Z>\n**What's Already Configured:**\n- NextJS 15.3.1 with App Directory structure (`src/app/`)\n- TailwindCSS 3.4.17 fully configured (`tailwind.config.js`, `postcss.config.js`)\n- ShadUI already set up (`components.json`, `@shadcn/ui` dependency)\n- TypeScript configuration (`tsconfig.json`)\n- Testing setup with Vitest\n- All required dependencies installed\n- Basic folder structure: `src/app/`, `src/tests/`, `public/`\n- Global CSS file (`src/app/globals.css`)\n- Root layout (`src/app/layout.tsx`) and page (`src/app/page.tsx`)\n- API routes structure (`src/app/api/`)\n\n**Current Status:** This subtask is complete - the project foundation is already properly set up and ready for development.\n\n**Next Steps:** Move to subtask 1.2 (Install and Configure TailwindCSS) which is also already complete, or proceed directly to subtask 1.3 (Install and Initialize ShadUI) which is also already done.\n</info added on 2025-08-23T05:17:09.909Z>",
            "status": "pending",
            "testStrategy": "Verify the NextJS dev server starts without errors. Confirm the App Directory structure is properly set up. Check that all required directories exist."
          },
          {
            "id": 2,
            "title": "Install and Configure TailwindCSS",
            "description": "Install TailwindCSS dependencies and configure it to work with the NextJS project.",
            "dependencies": [],
            "details": "Install TailwindCSS and its dependencies using `npm install -D tailwindcss postcss autoprefixer`. Initialize TailwindCSS with `npx tailwindcss init -p`. Configure tailwind.config.js to include app paths. Create a global CSS file with TailwindCSS directives.",
            "status": "pending",
            "testStrategy": "Confirm TailwindCSS styles are applied correctly. Test basic utility classes to ensure they work as expected."
          },
          {
            "id": 3,
            "title": "Install and Initialize ShadUI",
            "description": "Add ShadUI component library to the project and set up its configuration.",
            "dependencies": [],
            "details": "Install ShadUI using `npm install @shadcn/ui`. Initialize ShadUI with `npx shadcn-ui@latest init`. Configure ShadUI to work with the project's TailwindCSS setup. Set up the components.json configuration file.",
            "status": "pending",
            "testStrategy": "Test that ShadUI components render properly. Verify component styling is consistent with TailwindCSS configuration."
          },
          {
            "id": 4,
            "title": "Create Basic Layout Components",
            "description": "Develop foundational layout components that will structure the application.",
            "dependencies": [],
            "details": "Create a root layout component in app/layout.tsx that includes the global styles. Set up a page.tsx file in the app directory with a basic structure. Create placeholder components for main sections of the application.",
            "status": "pending",
            "testStrategy": "Ensure layout components render without errors. Test responsive behavior on different screen sizes. Validate that ShadUI components are properly integrated into the layout."
          },
          {
            "id": 5,
            "title": "Set Up Environment Variables and Testing",
            "description": "Configure environment variables and implement basic tests to verify the setup.",
            "dependencies": [],
            "details": "Create a .env.example file with required environment variables. Set up .env.local with development values. Configure NextJS to use the environment variables. Create a basic test to verify the project setup is working correctly.",
            "status": "pending",
            "testStrategy": "Validate environment variables are accessible in both client and server components. Test the overall project setup by running the development server and checking for any errors."
          }
        ]
      },
      {
        "id": 2,
        "title": "Set up Supabase Local Instance and Database Schema",
        "description": "Configure a local Supabase instance for development and create the necessary database schema for storing chat sessions and messages.",
        "details": "1. Install Supabase CLI: `npm install -g supabase`\n2. Initialize local Supabase: `supabase init`\n3. Start local Supabase: `supabase start`\n4. Create SQL migrations for the following tables:\n   - chat_sessions:\n     ```sql\n     CREATE TABLE chat_sessions (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       title TEXT NOT NULL\n     );\n     ```\n   - chat_messages:\n     ```sql\n     CREATE TABLE chat_messages (\n       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n       created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n       chat_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE,\n       role TEXT CHECK (role IN ('user', 'assistant')),\n       content TEXT NOT NULL,\n       type TEXT CHECK (type IN ('text', 'image')),\n       image_url TEXT\n     );\n     ```\n5. Apply migrations: `supabase db reset`\n6. Configure Supabase client in the application:\n   ```typescript\n   // lib/supabase.ts\n   import { createClient } from '@supabase/supabase-js';\n   \n   const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\n   const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n   \n   export const supabase = createClient(supabaseUrl, supabaseKey);\n   ```",
        "testStrategy": "1. Verify Supabase local instance is running\n2. Test database connection from the application\n3. Execute test queries to ensure tables are created correctly\n4. Validate foreign key constraints work as expected\n5. Test inserting and retrieving records from both tables",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Basic UI Layout and Components",
        "description": "Develop the foundational UI components and layout structure for the chat interface, including message containers, input area, and navigation elements.",
        "details": "1. Create layout components:\n   - components/layout/ChatLayout.tsx (main layout with sidebar and chat area)\n   - components/layout/Sidebar.tsx (for new chat button and future chat history)\n   - components/layout/ChatContainer.tsx (main chat area)\n\n2. Create message components:\n   - components/chat/MessageList.tsx (container for all messages)\n   - components/chat/Message.tsx (individual message component with user/AI styling)\n   - components/chat/MessageInput.tsx (text input with send button)\n\n3. Create UI elements:\n   - components/ui/Button.tsx (reusable button component)\n   - components/ui/Toggle.tsx (for switching between text and image modes)\n   - components/ui/NewChatButton.tsx (to start a new conversation)\n\n4. Implement responsive design using TailwindCSS:\n   ```tsx\n   // components/layout/ChatLayout.tsx example\n   export default function ChatLayout({ children }) {\n     return (\n       <div className=\"flex h-screen\">\n         <div className=\"w-64 border-r border-gray-200 hidden md:block\">\n           <Sidebar />\n         </div>\n         <div className=\"flex-1 flex flex-col\">\n           {children}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n5. Style messages to clearly differentiate between user and AI:\n   ```tsx\n   // components/chat/Message.tsx example\n   export default function Message({ role, content, type, imageUrl }) {\n     return (\n       <div className={`p-4 ${role === 'user' ? 'bg-blue-50' : 'bg-gray-50'}`}>\n         <div className=\"font-bold\">{role === 'user' ? 'You' : 'AI'}</div>\n         {type === 'text' ? (\n           <div className=\"mt-1\">{content}</div>\n         ) : (\n           <img src={imageUrl} alt=\"Generated image\" className=\"mt-2 rounded\" />\n         )}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test responsive layout on different screen sizes\n2. Verify components render correctly with sample data\n3. Check styling and visual differentiation between user and AI messages\n4. Validate that text and image message types display correctly\n5. Test accessibility using keyboard navigation and screen readers",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement OpenAI API Integration for Text Generation",
        "description": "Set up the integration with OpenAI's API for text generation using the GPT-4.1-nano model, including API key configuration and request handling.",
        "details": "1. Install OpenAI SDK: `npm install openai`\n\n2. Create OpenAI client configuration:\n   ```typescript\n   // lib/openai.ts\n   import OpenAI from 'openai';\n   \n   export const openai = new OpenAI({\n     apiKey: process.env.OPENAI_API_KEY,\n   });\n   ```\n\n3. Create a server action or API route for text generation:\n   ```typescript\n   // app/api/chat/route.ts\n   import { NextRequest, NextResponse } from 'next/server';\n   import { openai } from '@/lib/openai';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages } = await req.json();\n       \n       const response = await openai.chat.completions.create({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages,\n         temperature: 0.7,\n       });\n       \n       return NextResponse.json(response.choices[0].message);\n     } catch (error) {\n       console.error('OpenAI API error:', error);\n       return NextResponse.json(\n         { error: 'Failed to generate response' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n\n4. Create a utility function to format messages for the API:\n   ```typescript\n   // lib/utils.ts\n   export function formatChatMessages(messages) {\n     return messages.map(msg => ({\n       role: msg.role,\n       content: msg.content\n     }));\n   }\n   ```\n\n5. Add error handling and rate limit management",
        "testStrategy": "1. Test API integration with a simple message\n2. Verify error handling works when API key is invalid\n3. Test with various message formats and content\n4. Validate response format matches expected structure\n5. Test rate limit handling with mock responses",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Text Chat Functionality with State Management",
        "description": "Create the core chat functionality including state management for messages, user input handling, and basic conversation flow.",
        "details": "1. Create a chat context for state management:\n   ```typescript\n   // context/ChatContext.tsx\n   import { createContext, useContext, useState } from 'react';\n   \n   type Message = {\n     id: string;\n     role: 'user' | 'assistant';\n     content: string;\n     type: 'text' | 'image';\n     imageUrl?: string;\n   };\n   \n   type ChatContextType = {\n     messages: Message[];\n     addMessage: (message: Omit<Message, 'id'>) => void;\n     clearMessages: () => void;\n     isLoading: boolean;\n   };\n   \n   const ChatContext = createContext<ChatContextType | undefined>(undefined);\n   \n   export function ChatProvider({ children }) {\n     const [messages, setMessages] = useState<Message[]>([]);\n     const [isLoading, setIsLoading] = useState(false);\n     \n     const addMessage = (message: Omit<Message, 'id'>) => {\n       const newMessage = {\n         ...message,\n         id: Date.now().toString(),\n       };\n       setMessages(prev => [...prev, newMessage]);\n     };\n     \n     const clearMessages = () => setMessages([]);\n     \n     return (\n       <ChatContext.Provider value={{ messages, addMessage, clearMessages, isLoading }}>\n         {children}\n       </ChatContext.Provider>\n     );\n   }\n   \n   export const useChat = () => {\n     const context = useContext(ChatContext);\n     if (context === undefined) {\n       throw new Error('useChat must be used within a ChatProvider');\n     }\n     return context;\n   };\n   ```\n\n2. Implement the chat input component:\n   ```typescript\n   // components/chat/ChatInput.tsx\n   import { useState } from 'react';\n   import { useChat } from '@/context/ChatContext';\n   \n   export default function ChatInput() {\n     const [input, setInput] = useState('');\n     const { addMessage, isLoading } = useChat();\n     \n     const handleSubmit = async (e) => {\n       e.preventDefault();\n       if (!input.trim() || isLoading) return;\n       \n       // Add user message\n       addMessage({\n         role: 'user',\n         content: input,\n         type: 'text'\n       });\n       \n       setInput('');\n       \n       // API call will be added in the streaming task\n     };\n     \n     return (\n       <form onSubmit={handleSubmit} className=\"p-4 border-t\">\n         <div className=\"flex\">\n           <input\n             type=\"text\"\n             value={input}\n             onChange={(e) => setInput(e.target.value)}\n             placeholder=\"Type your message...\"\n             className=\"flex-1 p-2 border rounded-l\"\n             disabled={isLoading}\n           />\n           <button \n             type=\"submit\" \n             className=\"bg-blue-500 text-white p-2 rounded-r\"\n             disabled={isLoading}\n           >\n             Send\n           </button>\n         </div>\n       </form>\n     );\n   }\n   ```\n\n3. Create the message list component:\n   ```typescript\n   // components/chat/MessageList.tsx\n   import { useChat } from '@/context/ChatContext';\n   import Message from './Message';\n   \n   export default function MessageList() {\n     const { messages } = useChat();\n     \n     return (\n       <div className=\"flex-1 overflow-y-auto p-4\">\n         {messages.length === 0 ? (\n           <div className=\"text-center text-gray-500 mt-10\">\n             Start a conversation by typing a message below.\n           </div>\n         ) : (\n           messages.map(message => (\n             <Message key={message.id} {...message} />\n           ))\n         )}\n       </div>\n     );\n   }\n   ```\n\n4. Integrate components in the main chat page:\n   ```typescript\n   // app/page.tsx\n   import { ChatProvider } from '@/context/ChatContext';\n   import ChatLayout from '@/components/layout/ChatLayout';\n   import MessageList from '@/components/chat/MessageList';\n   import ChatInput from '@/components/chat/ChatInput';\n   \n   export default function Home() {\n     return (\n       <ChatProvider>\n         <ChatLayout>\n           <div className=\"flex flex-col h-full\">\n             <MessageList />\n             <ChatInput />\n           </div>\n         </ChatLayout>\n       </ChatProvider>\n     );\n   }\n   ```",
        "testStrategy": "1. Test adding messages to the chat\n2. Verify empty state displays correctly\n3. Test input validation and submission\n4. Check that messages render in the correct order\n5. Validate disabled states during loading\n6. Test context provider with multiple components",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Streaming Response Functionality",
        "description": "Add streaming capability to display AI responses in real-time as they're generated, enhancing the user experience with immediate feedback.",
        "details": "1. Create a streaming API route:\n   ```typescript\n   // app/api/chat/stream/route.ts\n   import { NextRequest, NextResponse } from 'next/server';\n   import { openai } from '@/lib/openai';\n   import { StreamingTextResponse } from 'ai';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages } = await req.json();\n       \n       const response = await openai.chat.completions.create({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages,\n         temperature: 0.7,\n         stream: true,\n       });\n       \n       return new StreamingTextResponse(response.body);\n     } catch (error) {\n       console.error('OpenAI API error:', error);\n       return NextResponse.json(\n         { error: 'Failed to generate response' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n\n2. Install the Vercel AI SDK: `npm install ai`\n\n3. Update the chat context to handle streaming:\n   ```typescript\n   // context/ChatContext.tsx (additions)\n   import { useState } from 'react';\n   \n   // Add to ChatContextType\n   streamingContent: string;\n   setStreamingContent: (content: string) => void;\n   \n   // Add to ChatProvider\n   const [streamingContent, setStreamingContent] = useState('');\n   \n   // Include in provider value\n   value={{ \n     // existing values\n     streamingContent, \n     setStreamingContent \n   }}\n   ```\n\n4. Update the ChatInput component to handle streaming:\n   ```typescript\n   // components/chat/ChatInput.tsx (updated handleSubmit)\n   import { useChat } from '@/context/ChatContext';\n   \n   const handleSubmit = async (e) => {\n     e.preventDefault();\n     if (!input.trim() || isLoading) return;\n     \n     // Add user message\n     addMessage({\n       role: 'user',\n       content: input,\n       type: 'text'\n     });\n     \n     setInput('');\n     setIsLoading(true);\n     setStreamingContent('');\n     \n     // Add placeholder assistant message\n     addMessage({\n       role: 'assistant',\n       content: '',\n       type: 'text'\n     });\n     \n     try {\n       const response = await fetch('/api/chat/stream', {\n         method: 'POST',\n         headers: { 'Content-Type': 'application/json' },\n         body: JSON.stringify({\n           messages: formatChatMessages(messages.concat({\n             role: 'user',\n             content: input,\n           })),\n         }),\n       });\n       \n       if (!response.ok) throw new Error('Failed to fetch response');\n       \n       const reader = response.body.getReader();\n       const decoder = new TextDecoder();\n       let done = false;\n       let accumulatedContent = '';\n       \n       while (!done) {\n         const { value, done: doneReading } = await reader.read();\n         done = doneReading;\n         \n         if (value) {\n           const chunk = decoder.decode(value, { stream: true });\n           accumulatedContent += chunk;\n           setStreamingContent(accumulatedContent);\n         }\n       }\n       \n       // Update the last message with the complete content\n       setMessages(prev => {\n         const updated = [...prev];\n         updated[updated.length - 1].content = accumulatedContent;\n         return updated;\n       });\n       \n     } catch (error) {\n       console.error('Error:', error);\n       // Handle error\n     } finally {\n       setIsLoading(false);\n       setStreamingContent('');\n     }\n   };\n   ```\n\n5. Update the MessageList component to display streaming content:\n   ```typescript\n   // components/chat/MessageList.tsx (updated)\n   import { useChat } from '@/context/ChatContext';\n   import Message from './Message';\n   \n   export default function MessageList() {\n     const { messages, streamingContent, isLoading } = useChat();\n     \n     return (\n       <div className=\"flex-1 overflow-y-auto p-4\">\n         {messages.length === 0 ? (\n           <div className=\"text-center text-gray-500 mt-10\">\n             Start a conversation by typing a message below.\n           </div>\n         ) : (\n           <>\n             {messages.map((message, index) => {\n               // For the last assistant message, show streaming content if available\n               const isLastAssistantMessage = \n                 index === messages.length - 1 && \n                 message.role === 'assistant' &&\n                 isLoading;\n               \n               return (\n                 <Message \n                   key={message.id} \n                   {...message} \n                   content={isLastAssistantMessage ? streamingContent : message.content}\n                 />\n               );\n             })}\n           </>\n         )}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test streaming response with various message lengths\n2. Verify text appears incrementally as it's received\n3. Test error handling during streaming\n4. Validate the final message content is complete\n5. Test with slow network conditions\n6. Verify UI updates correctly during streaming",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Supabase Integration for Message Storage",
        "description": "Connect the chat application to Supabase for persistent storage of chat sessions and messages, allowing conversations to be saved and retrieved.",
        "details": "1. Create utility functions for Supabase operations:\n   ```typescript\n   // lib/supabase-utils.ts\n   import { supabase } from './supabase';\n   \n   export async function createChatSession(title: string) {\n     const { data, error } = await supabase\n       .from('chat_sessions')\n       .insert({ title })\n       .select()\n       .single();\n       \n     if (error) throw error;\n     return data;\n   }\n   \n   export async function saveChatMessage(message: {\n     chat_id: string;\n     role: 'user' | 'assistant';\n     content: string;\n     type: 'text' | 'image';\n     image_url?: string;\n   }) {\n     const { data, error } = await supabase\n       .from('chat_messages')\n       .insert(message)\n       .select()\n       .single();\n       \n     if (error) throw error;\n     return data;\n   }\n   \n   export async function getChatSession(id: string) {\n     const { data: session, error: sessionError } = await supabase\n       .from('chat_sessions')\n       .select('*')\n       .eq('id', id)\n       .single();\n       \n     if (sessionError) throw sessionError;\n     \n     const { data: messages, error: messagesError } = await supabase\n       .from('chat_messages')\n       .select('*')\n       .eq('chat_id', id)\n       .order('created_at', { ascending: true });\n       \n     if (messagesError) throw messagesError;\n     \n     return {\n       session,\n       messages\n     };\n   }\n   \n   export async function getAllChatSessions() {\n     const { data, error } = await supabase\n       .from('chat_sessions')\n       .select('*')\n       .order('updated_at', { ascending: false });\n       \n     if (error) throw error;\n     return data;\n   }\n   ```\n\n2. Update the ChatContext to include session management:\n   ```typescript\n   // context/ChatContext.tsx (additions)\n   import { createChatSession, saveChatMessage, getChatSession } from '@/lib/supabase-utils';\n   \n   // Add to ChatContextType\n   currentSessionId: string | null;\n   startNewSession: () => Promise<void>;\n   loadSession: (id: string) => Promise<void>;\n   \n   // Add to ChatProvider\n   const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);\n   \n   const startNewSession = async () => {\n     try {\n       setIsLoading(true);\n       clearMessages();\n       \n       // Create a new session with a default title\n       const session = await createChatSession('New Chat');\n       setCurrentSessionId(session.id);\n       \n     } catch (error) {\n       console.error('Failed to create new session:', error);\n     } finally {\n       setIsLoading(false);\n     }\n   };\n   \n   const loadSession = async (id: string) => {\n     try {\n       setIsLoading(true);\n       \n       const { session, messages: chatMessages } = await getChatSession(id);\n       setCurrentSessionId(session.id);\n       \n       // Convert Supabase messages to app format\n       const formattedMessages = chatMessages.map(msg => ({\n         id: msg.id,\n         role: msg.role as 'user' | 'assistant',\n         content: msg.content,\n         type: msg.type as 'text' | 'image',\n         imageUrl: msg.image_url\n       }));\n       \n       setMessages(formattedMessages);\n       \n     } catch (error) {\n       console.error('Failed to load session:', error);\n     } finally {\n       setIsLoading(false);\n     }\n   };\n   \n   // Modify addMessage to save to Supabase\n   const addMessage = async (message: Omit<Message, 'id'>) => {\n     const newMessage = {\n       ...message,\n       id: Date.now().toString(),\n     };\n     \n     setMessages(prev => [...prev, newMessage]);\n     \n     // Save to Supabase if we have a session\n     if (currentSessionId) {\n       try {\n         await saveChatMessage({\n           chat_id: currentSessionId,\n           role: message.role,\n           content: message.content,\n           type: message.type,\n           image_url: message.imageUrl\n         });\n         \n         // Update session title if it's the first user message\n         if (messages.length === 0 && message.role === 'user') {\n           const title = message.content.slice(0, 50) + (message.content.length > 50 ? '...' : '');\n           await supabase\n             .from('chat_sessions')\n             .update({ title })\n             .eq('id', currentSessionId);\n         }\n       } catch (error) {\n         console.error('Failed to save message:', error);\n       }\n     }\n   };\n   ```\n\n3. Update the ChatInput component to initialize a session if needed:\n   ```typescript\n   // components/chat/ChatInput.tsx (updated handleSubmit)\n   const handleSubmit = async (e) => {\n     e.preventDefault();\n     if (!input.trim() || isLoading) return;\n     \n     // Create a new session if one doesn't exist\n     if (!currentSessionId) {\n       await startNewSession();\n     }\n     \n     // Rest of the function remains the same\n     // ...\n   };\n   ```\n\n4. Create a component to list chat sessions in the sidebar:\n   ```typescript\n   // components/chat/ChatSessionList.tsx\n   import { useEffect, useState } from 'react';\n   import { getAllChatSessions } from '@/lib/supabase-utils';\n   import { useChat } from '@/context/ChatContext';\n   \n   export default function ChatSessionList() {\n     const [sessions, setSessions] = useState([]);\n     const { loadSession, currentSessionId } = useChat();\n     \n     useEffect(() => {\n       const fetchSessions = async () => {\n         try {\n           const data = await getAllChatSessions();\n           setSessions(data);\n         } catch (error) {\n           console.error('Failed to fetch sessions:', error);\n         }\n       };\n       \n       fetchSessions();\n     }, [currentSessionId]); // Refresh when current session changes\n     \n     return (\n       <div className=\"mt-4\">\n         <h2 className=\"px-4 text-sm font-medium text-gray-500\">Chat History</h2>\n         <ul className=\"mt-2\">\n           {sessions.map(session => (\n             <li \n               key={session.id} \n               className={`px-4 py-2 cursor-pointer hover:bg-gray-100 ${currentSessionId === session.id ? 'bg-blue-50' : ''}`}\n               onClick={() => loadSession(session.id)}\n             >\n               {session.title}\n             </li>\n           ))}\n         </ul>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test creating a new chat session\n2. Verify messages are saved to Supabase\n3. Test loading an existing session\n4. Validate session list updates correctly\n5. Test error handling for database operations\n6. Verify session title is updated based on first message",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement OpenAI Image Generation Integration",
        "description": "Add the capability to generate images using OpenAI's gpt-image-1 model, including API integration and image display functionality.",
        "details": "1. Create an API route for image generation:\n   ```typescript\n   // app/api/image/route.ts\n   import { NextRequest, NextResponse } from 'next/server';\n   import { openai } from '@/lib/openai';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { prompt } = await req.json();\n       \n       const response = await openai.images.generate({\n         model: 'gpt-image-1',\n         prompt,\n         n: 1,\n         size: '1024x1024',\n       });\n       \n       return NextResponse.json({\n         url: response.data[0].url\n       });\n     } catch (error) {\n       console.error('OpenAI API error:', error);\n       return NextResponse.json(\n         { error: 'Failed to generate image' },\n         { status: 500 }\n       );\n     }\n   }\n   ```\n\n2. Create a toggle component for switching between text and image modes:\n   ```typescript\n   // components/chat/ModeToggle.tsx\n   import { useState } from 'react';\n   \n   type Mode = 'text' | 'image';\n   \n   interface ModeToggleProps {\n     mode: Mode;\n     onModeChange: (mode: Mode) => void;\n   }\n   \n   export default function ModeToggle({ mode, onModeChange }: ModeToggleProps) {\n     return (\n       <div className=\"flex border rounded overflow-hidden\">\n         <button\n           className={`px-4 py-2 ${mode === 'text' ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}\n           onClick={() => onModeChange('text')}\n         >\n           Text\n         </button>\n         <button\n           className={`px-4 py-2 ${mode === 'image' ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}\n           onClick={() => onModeChange('image')}\n         >\n           Image\n         </button>\n       </div>\n     );\n   }\n   ```\n\n3. Update the ChatInput component to handle image generation:\n   ```typescript\n   // components/chat/ChatInput.tsx (updated)\n   import { useState } from 'react';\n   import { useChat } from '@/context/ChatContext';\n   import ModeToggle from './ModeToggle';\n   \n   export default function ChatInput() {\n     const [input, setInput] = useState('');\n     const [mode, setMode] = useState<'text' | 'image'>('text');\n     const { addMessage, isLoading, currentSessionId, startNewSession } = useChat();\n     \n     const handleSubmit = async (e) => {\n       e.preventDefault();\n       if (!input.trim() || isLoading) return;\n       \n       // Create a new session if one doesn't exist\n       if (!currentSessionId) {\n         await startNewSession();\n       }\n       \n       // Add user message\n       addMessage({\n         role: 'user',\n         content: input,\n         type: 'text'\n       });\n       \n       setInput('');\n       \n       if (mode === 'text') {\n         // Text generation logic (from previous task)\n         // ...\n       } else {\n         // Image generation\n         try {\n           setIsLoading(true);\n           \n           const response = await fetch('/api/image', {\n             method: 'POST',\n             headers: { 'Content-Type': 'application/json' },\n             body: JSON.stringify({ prompt: input }),\n           });\n           \n           if (!response.ok) throw new Error('Failed to generate image');\n           \n           const { url } = await response.json();\n           \n           // Add AI response with image\n           addMessage({\n             role: 'assistant',\n             content: 'Here\\'s the image you requested:',\n             type: 'image',\n             imageUrl: url\n           });\n           \n         } catch (error) {\n           console.error('Error generating image:', error);\n           \n           // Add error message\n           addMessage({\n             role: 'assistant',\n             content: 'Sorry, I couldn\\'t generate that image. Please try again with a different description.',\n             type: 'text'\n           });\n           \n         } finally {\n           setIsLoading(false);\n         }\n       }\n     };\n     \n     return (\n       <div className=\"p-4 border-t\">\n         <div className=\"flex justify-center mb-4\">\n           <ModeToggle mode={mode} onModeChange={setMode} />\n         </div>\n         <form onSubmit={handleSubmit} className=\"flex\">\n           <input\n             type=\"text\"\n             value={input}\n             onChange={(e) => setInput(e.target.value)}\n             placeholder={mode === 'text' ? \"Type your message...\" : \"Describe the image you want...\"}\n             className=\"flex-1 p-2 border rounded-l\"\n             disabled={isLoading}\n           />\n           <button \n             type=\"submit\" \n             className=\"bg-blue-500 text-white p-2 rounded-r\"\n             disabled={isLoading}\n           >\n             {isLoading ? 'Processing...' : mode === 'text' ? 'Send' : 'Generate'}\n           </button>\n         </form>\n       </div>\n     );\n   }\n   ```\n\n4. Update the Message component to handle image display:\n   ```typescript\n   // components/chat/Message.tsx (updated)\n   export default function Message({ role, content, type, imageUrl }) {\n     return (\n       <div className={`p-4 mb-4 rounded ${role === 'user' ? 'bg-blue-50' : 'bg-gray-50'}`}>\n         <div className=\"font-bold\">{role === 'user' ? 'You' : 'AI'}</div>\n         <div className=\"mt-1\">\n           {content}\n           {type === 'image' && imageUrl && (\n             <div className=\"mt-2\">\n               <img \n                 src={imageUrl} \n                 alt=\"Generated image\" \n                 className=\"max-w-full rounded shadow-sm\" \n                 style={{ maxHeight: '512px' }}\n               />\n             </div>\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test switching between text and image modes\n2. Verify image generation API calls work correctly\n3. Test image display in the message list\n4. Validate error handling for failed image generation\n5. Test with various image prompts\n6. Verify images are saved correctly in Supabase",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement New Chat Functionality",
        "description": "Add the ability to start a new chat session, clearing the current conversation while preserving previous chats in the database.",
        "details": "1. Create a NewChatButton component:\n   ```typescript\n   // components/chat/NewChatButton.tsx\n   import { useChat } from '@/context/ChatContext';\n   \n   export default function NewChatButton() {\n     const { startNewSession, isLoading } = useChat();\n     \n     return (\n       <button\n         onClick={startNewSession}\n         disabled={isLoading}\n         className=\"w-full flex items-center justify-center px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-blue-300\"\n       >\n         <svg\n           xmlns=\"http://www.w3.org/2000/svg\"\n           className=\"h-5 w-5 mr-2\"\n           viewBox=\"0 0 20 20\"\n           fill=\"currentColor\"\n         >\n           <path\n             fillRule=\"evenodd\"\n             d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\"\n             clipRule=\"evenodd\"\n           />\n         </svg>\n         New Chat\n       </button>\n     );\n   }\n   ```\n\n2. Update the Sidebar component to include the new chat button and session list:\n   ```typescript\n   // components/layout/Sidebar.tsx\n   import NewChatButton from '@/components/chat/NewChatButton';\n   import ChatSessionList from '@/components/chat/ChatSessionList';\n   \n   export default function Sidebar() {\n     return (\n       <div className=\"h-full flex flex-col p-4\">\n         <NewChatButton />\n         <ChatSessionList />\n       </div>\n     );\n   }\n   ```\n\n3. Add a mobile-friendly new chat button in the header for smaller screens:\n   ```typescript\n   // components/layout/Header.tsx\n   import { useChat } from '@/context/ChatContext';\n   \n   export default function Header() {\n     const { startNewSession, isLoading } = useChat();\n     \n     return (\n       <header className=\"border-b p-4 flex items-center justify-between md:hidden\">\n         <h1 className=\"text-xl font-bold\">AI Chat</h1>\n         <button\n           onClick={startNewSession}\n           disabled={isLoading}\n           className=\"p-2 rounded-full bg-blue-500 text-white\"\n           aria-label=\"New Chat\"\n         >\n           <svg\n             xmlns=\"http://www.w3.org/2000/svg\"\n             className=\"h-5 w-5\"\n             viewBox=\"0 0 20 20\"\n             fill=\"currentColor\"\n           >\n             <path\n               fillRule=\"evenodd\"\n               d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\"\n               clipRule=\"evenodd\"\n             />\n           </svg>\n         </button>\n       </header>\n     );\n   }\n   ```\n\n4. Update the main layout to include the header:\n   ```typescript\n   // components/layout/ChatLayout.tsx (updated)\n   import Sidebar from './Sidebar';\n   import Header from './Header';\n   \n   export default function ChatLayout({ children }) {\n     return (\n       <div className=\"flex h-screen\">\n         <div className=\"w-64 border-r border-gray-200 hidden md:block\">\n           <Sidebar />\n         </div>\n         <div className=\"flex-1 flex flex-col\">\n           <Header />\n           {children}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n5. Ensure the ChatContext's startNewSession function is properly implemented (from Task 7):\n   ```typescript\n   // From context/ChatContext.tsx\n   const startNewSession = async () => {\n     try {\n       setIsLoading(true);\n       clearMessages();\n       \n       // Create a new session with a default title\n       const session = await createChatSession('New Chat');\n       setCurrentSessionId(session.id);\n       \n     } catch (error) {\n       console.error('Failed to create new session:', error);\n     } finally {\n       setIsLoading(false);\n     }\n   };\n   ```",
        "testStrategy": "1. Test creating a new chat session with the button\n2. Verify the current conversation is cleared\n3. Test that previous conversations are preserved in the database\n4. Validate the new session appears in the session list\n5. Test the mobile new chat button functionality\n6. Verify the UI state during loading",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Error Handling and Loading States",
        "description": "Add comprehensive error handling throughout the application and implement loading states to provide feedback during API calls and database operations.",
        "details": "1. Create reusable error and loading components:\n   ```typescript\n   // components/ui/ErrorMessage.tsx\n   interface ErrorMessageProps {\n     message: string;\n     onRetry?: () => void;\n   }\n   \n   export default function ErrorMessage({ message, onRetry }: ErrorMessageProps) {\n     return (\n       <div className=\"p-4 bg-red-50 border border-red-200 rounded text-red-700 mb-4\">\n         <p>{message}</p>\n         {onRetry && (\n           <button\n             onClick={onRetry}\n             className=\"mt-2 px-3 py-1 bg-red-100 text-red-800 rounded hover:bg-red-200\"\n           >\n             Try Again\n           </button>\n         )}\n       </div>\n     );\n   }\n   ```\n\n   ```typescript\n   // components/ui/LoadingSpinner.tsx\n   interface LoadingSpinnerProps {\n     size?: 'small' | 'medium' | 'large';\n     message?: string;\n   }\n   \n   export default function LoadingSpinner({ size = 'medium', message }: LoadingSpinnerProps) {\n     const sizeClasses = {\n       small: 'w-4 h-4',\n       medium: 'w-8 h-8',\n       large: 'w-12 h-12'\n     };\n     \n     return (\n       <div className=\"flex flex-col items-center justify-center p-4\">\n         <div className={`animate-spin rounded-full border-t-2 border-blue-500 ${sizeClasses[size]}`}></div>\n         {message && <p className=\"mt-2 text-gray-500\">{message}</p>}\n       </div>\n     );\n   }\n   ```\n\n2. Update the ChatContext to include error state:\n   ```typescript\n   // context/ChatContext.tsx (additions)\n   // Add to ChatContextType\n   error: string | null;\n   clearError: () => void;\n   \n   // Add to ChatProvider\n   const [error, setError] = useState<string | null>(null);\n   \n   const clearError = () => setError(null);\n   \n   // Update error handling in functions\n   const startNewSession = async () => {\n     try {\n       setIsLoading(true);\n       clearError();\n       clearMessages();\n       \n       const session = await createChatSession('New Chat');\n       setCurrentSessionId(session.id);\n       \n     } catch (error) {\n       console.error('Failed to create new session:', error);\n       setError('Failed to create new chat session. Please try again.');\n     } finally {\n       setIsLoading(false);\n     }\n   };\n   \n   // Similar updates for other functions\n   ```\n\n3. Update the ChatInput component to handle errors and show loading states:\n   ```typescript\n   // components/chat/ChatInput.tsx (updated)\n   import { useState } from 'react';\n   import { useChat } from '@/context/ChatContext';\n   import ModeToggle from './ModeToggle';\n   import LoadingSpinner from '../ui/LoadingSpinner';\n   import ErrorMessage from '../ui/ErrorMessage';\n   \n   export default function ChatInput() {\n     // Existing state\n     const { addMessage, isLoading, error, clearError, currentSessionId, startNewSession } = useChat();\n     const [localError, setLocalError] = useState<string | null>(null);\n     \n     const handleSubmit = async (e) => {\n       e.preventDefault();\n       if (!input.trim() || isLoading) return;\n       \n       setLocalError(null);\n       clearError();\n       \n       try {\n         // Create a new session if one doesn't exist\n         if (!currentSessionId) {\n           await startNewSession();\n         }\n         \n         // Add user message\n         addMessage({\n           role: 'user',\n           content: input,\n           type: 'text'\n         });\n         \n         setInput('');\n         \n         // Rest of function with try/catch blocks\n         // ...\n       } catch (error) {\n         console.error('Error:', error);\n         setLocalError('Failed to process your request. Please try again.');\n       }\n     };\n     \n     return (\n       <div className=\"p-4 border-t\">\n         {(error || localError) && (\n           <ErrorMessage \n             message={error || localError || 'An error occurred'} \n             onRetry={clearError} \n           />\n         )}\n         \n         <div className=\"flex justify-center mb-4\">\n           <ModeToggle mode={mode} onModeChange={setMode} />\n         </div>\n         \n         {isLoading && (\n           <div className=\"absolute inset-0 flex items-center justify-center bg-white bg-opacity-50 z-10\">\n             <LoadingSpinner message={mode === 'text' ? 'Generating response...' : 'Creating image...'} />\n           </div>\n         )}\n         \n         <form onSubmit={handleSubmit} className=\"flex\">\n           {/* Input and button */}\n         </form>\n       </div>\n     );\n   }\n   ```\n\n4. Add loading states to the MessageList component:\n   ```typescript\n   // components/chat/MessageList.tsx (updated)\n   import { useChat } from '@/context/ChatContext';\n   import Message from './Message';\n   import LoadingSpinner from '../ui/LoadingSpinner';\n   \n   export default function MessageList() {\n     const { messages, streamingContent, isLoading, error } = useChat();\n     \n     return (\n       <div className=\"flex-1 overflow-y-auto p-4 relative\">\n         {messages.length === 0 ? (\n           <div className=\"text-center text-gray-500 mt-10\">\n             {isLoading ? (\n               <LoadingSpinner message=\"Starting new chat...\" />\n             ) : error ? (\n               <div className=\"text-red-500\">{error}</div>\n             ) : (\n               'Start a conversation by typing a message below.'\n             )}\n           </div>\n         ) : (\n           // Messages rendering\n         )}\n       </div>\n     );\n   }\n   ```\n\n5. Add error handling to the API routes:\n   ```typescript\n   // app/api/chat/stream/route.ts (updated error handling)\n   export async function POST(req: NextRequest) {\n     try {\n       // Validate request body\n       const body = await req.json();\n       if (!body.messages || !Array.isArray(body.messages)) {\n         return NextResponse.json(\n           { error: 'Invalid request format' },\n           { status: 400 }\n         );\n       }\n       \n       // Rest of function\n       // ...\n     } catch (error) {\n       console.error('OpenAI API error:', error);\n       \n       // Detailed error response based on error type\n       if (error.response?.status === 429) {\n         return NextResponse.json(\n           { error: 'Rate limit exceeded. Please try again later.' },\n           { status: 429 }\n         );\n       }\n       \n       return NextResponse.json(\n         { error: 'Failed to generate response' },\n         { status: 500 }\n       );\n     }\n   }\n   ```",
        "testStrategy": "1. Test error handling for API failures\n2. Verify loading states appear during operations\n3. Test error recovery and retry functionality\n4. Validate error messages are clear and helpful\n5. Test rate limit error handling\n6. Verify loading indicators are appropriate for each operation",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Response Formatting and Display Enhancements",
        "description": "Improve the formatting and display of AI responses, including markdown rendering, code highlighting, and proper handling of different content types.",
        "details": "1. Install markdown and syntax highlighting libraries:\n   ```bash\n   npm install react-markdown rehype-highlight rehype-raw remark-gfm\n   ```\n\n2. Create an enhanced message display component:\n   ```typescript\n   // components/chat/FormattedMessage.tsx\n   import ReactMarkdown from 'react-markdown';\n   import rehypeHighlight from 'rehype-highlight';\n   import rehypeRaw from 'rehype-raw';\n   import remarkGfm from 'remark-gfm';\n   import 'highlight.js/styles/github.css';\n   \n   interface FormattedMessageProps {\n     content: string;\n   }\n   \n   export default function FormattedMessage({ content }: FormattedMessageProps) {\n     return (\n       <div className=\"prose prose-sm max-w-none\">\n         <ReactMarkdown\n           rehypePlugins={[rehypeHighlight, rehypeRaw]}\n           remarkPlugins={[remarkGfm]}\n         >\n           {content}\n         </ReactMarkdown>\n       </div>\n     );\n   }\n   ```\n\n3. Update the Message component to use the formatted display:\n   ```typescript\n   // components/chat/Message.tsx (updated)\n   import FormattedMessage from './FormattedMessage';\n   \n   export default function Message({ role, content, type, imageUrl }) {\n     return (\n       <div className={`p-4 mb-4 rounded ${role === 'user' ? 'bg-blue-50' : 'bg-gray-50'}`}>\n         <div className=\"font-bold\">{role === 'user' ? 'You' : 'AI'}</div>\n         <div className=\"mt-1\">\n           {type === 'text' ? (\n             <FormattedMessage content={content} />\n           ) : (\n             <div>\n               {content}\n               {imageUrl && (\n                 <div className=\"mt-2\">\n                   <img \n                     src={imageUrl} \n                     alt=\"Generated image\" \n                     className=\"max-w-full rounded shadow-sm\" \n                     style={{ maxHeight: '512px' }}\n                   />\n                 </div>\n               )}\n             </div>\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n4. Add TailwindCSS configuration for prose styling:\n   ```javascript\n   // tailwind.config.js (update)\n   module.exports = {\n     // existing config\n     plugins: [\n       require('@tailwindcss/typography'),\n       // other plugins\n     ],\n   };\n   ```\n\n5. Install the typography plugin:\n   ```bash\n   npm install -D @tailwindcss/typography\n   ```\n\n6. Enhance the streaming display to handle markdown:\n   ```typescript\n   // components/chat/MessageList.tsx (updated streaming display)\n   import { useChat } from '@/context/ChatContext';\n   import Message from './Message';\n   import FormattedMessage from './FormattedMessage';\n   \n   export default function MessageList() {\n     const { messages, streamingContent, isLoading } = useChat();\n     \n     return (\n       <div className=\"flex-1 overflow-y-auto p-4\">\n         {messages.length === 0 ? (\n           // Empty state\n         ) : (\n           <>\n             {messages.map((message, index) => {\n               // For the last assistant message, show streaming content if available\n               const isLastAssistantMessage = \n                 index === messages.length - 1 && \n                 message.role === 'assistant' &&\n                 isLoading;\n               \n               if (isLastAssistantMessage && streamingContent) {\n                 return (\n                   <div key={message.id} className=\"p-4 mb-4 rounded bg-gray-50\">\n                     <div className=\"font-bold\">AI</div>\n                     <div className=\"mt-1\">\n                       <FormattedMessage content={streamingContent} />\n                     </div>\n                   </div>\n                 );\n               }\n               \n               return <Message key={message.id} {...message} />;\n             })}\n           </>\n         )}\n       </div>\n     );\n   }\n   ```\n\n7. Add special handling for code blocks in the OpenAI prompt:\n   ```typescript\n   // lib/utils.ts (addition)\n   export function enhancePrompt(prompt: string) {\n     return `${prompt}\\n\\nPlease format your response using markdown where appropriate. For code examples, use markdown code blocks with language specification.`;\n   }\n   ```\n\n8. Update the API call to use the enhanced prompt:\n   ```typescript\n   // app/api/chat/stream/route.ts (updated)\n   import { enhancePrompt } from '@/lib/utils';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages } = await req.json();\n       \n       // Enhance the last user message if it exists\n       if (messages.length > 0 && messages[messages.length - 1].role === 'user') {\n         messages[messages.length - 1].content = enhancePrompt(messages[messages.length - 1].content);\n       }\n       \n       // Rest of function\n       // ...\n     } catch (error) {\n       // Error handling\n     }\n   }\n   ```",
        "testStrategy": "1. Test markdown rendering with various content types\n2. Verify code blocks are highlighted correctly\n3. Test tables, lists, and other markdown elements\n4. Validate streaming content renders markdown properly\n5. Test with long and complex responses\n6. Verify image display alongside formatted text",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Responsive Design Improvements",
        "description": "Enhance the application's responsiveness to ensure optimal user experience across different device sizes, from mobile to desktop.",
        "details": "1. Update the main layout for better responsiveness:\n   ```typescript\n   // components/layout/ChatLayout.tsx (improved)\n   import { useState } from 'react';\n   import Sidebar from './Sidebar';\n   import Header from './Header';\n   \n   export default function ChatLayout({ children }) {\n     const [sidebarOpen, setSidebarOpen] = useState(false);\n     \n     return (\n       <div className=\"flex h-screen\">\n         {/* Mobile sidebar (overlay) */}\n         {sidebarOpen && (\n           <div className=\"fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden\" onClick={() => setSidebarOpen(false)}></div>\n         )}\n         \n         {/* Sidebar */}\n         <div \n           className={`fixed md:static inset-y-0 left-0 w-64 bg-white border-r border-gray-200 z-50 transform transition-transform duration-300 ease-in-out md:transform-none ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'} md:flex`}\n         >\n           <div className=\"flex-1 overflow-y-auto\">\n             <Sidebar />\n           </div>\n         </div>\n         \n         {/* Main content */}\n         <div className=\"flex-1 flex flex-col w-full\">\n           <Header onMenuClick={() => setSidebarOpen(true)} />\n           <main className=\"flex-1 flex flex-col overflow-hidden\">\n             {children}\n           </main>\n         </div>\n       </div>\n     );\n   }\n   ```\n\n2. Update the Header component with a menu button:\n   ```typescript\n   // components/layout/Header.tsx (updated)\n   import { useChat } from '@/context/ChatContext';\n   \n   interface HeaderProps {\n     onMenuClick: () => void;\n   }\n   \n   export default function Header({ onMenuClick }: HeaderProps) {\n     const { startNewSession, isLoading } = useChat();\n     \n     return (\n       <header className=\"border-b p-4 flex items-center justify-between\">\n         <div className=\"flex items-center\">\n           <button\n             onClick={onMenuClick}\n             className=\"p-2 rounded-full text-gray-500 hover:bg-gray-100 md:hidden\"\n             aria-label=\"Open menu\"\n           >\n             <svg\n               xmlns=\"http://www.w3.org/2000/svg\"\n               className=\"h-6 w-6\"\n               fill=\"none\"\n               viewBox=\"0 0 24 24\"\n               stroke=\"currentColor\"\n             >\n               <path\n                 strokeLinecap=\"round\"\n                 strokeLinejoin=\"round\"\n                 strokeWidth={2}\n                 d=\"M4 6h16M4 12h16M4 18h16\"\n               />\n             </svg>\n           </button>\n           <h1 className=\"text-xl font-bold ml-2\">AI Chat</h1>\n         </div>\n         \n         <button\n           onClick={startNewSession}\n           disabled={isLoading}\n           className=\"p-2 rounded-full bg-blue-500 text-white md:hidden\"\n           aria-label=\"New Chat\"\n         >\n           <svg\n             xmlns=\"http://www.w3.org/2000/svg\"\n             className=\"h-5 w-5\"\n             viewBox=\"0 0 20 20\"\n             fill=\"currentColor\"\n           >\n             <path\n               fillRule=\"evenodd\"\n               d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\"\n               clipRule=\"evenodd\"\n             />\n           </svg>\n         </button>\n       </header>\n     );\n   }\n   ```\n\n3. Improve the MessageList component for better mobile experience:\n   ```typescript\n   // components/chat/MessageList.tsx (responsive improvements)\n   export default function MessageList() {\n     // Existing code\n     \n     return (\n       <div className=\"flex-1 overflow-y-auto p-2 sm:p-4\">\n         {/* Existing content */}\n       </div>\n     );\n   }\n   ```\n\n4. Update the ChatInput component for mobile:\n   ```typescript\n   // components/chat/ChatInput.tsx (responsive improvements)\n   export default function ChatInput() {\n     // Existing code\n     \n     return (\n       <div className=\"p-2 sm:p-4 border-t\">\n         {/* Error message */}\n         \n         <div className=\"flex justify-center mb-2 sm:mb-4\">\n           <ModeToggle mode={mode} onModeChange={setMode} />\n         </div>\n         \n         {/* Loading indicator */}\n         \n         <form onSubmit={handleSubmit} className=\"flex\">\n           <input\n             type=\"text\"\n             value={input}\n             onChange={(e) => setInput(e.target.value)}\n             placeholder={mode === 'text' ? \"Type your message...\" : \"Describe the image you want...\"}\n             className=\"flex-1 p-2 text-sm sm:text-base border rounded-l\"\n             disabled={isLoading}\n           />\n           <button \n             type=\"submit\" \n             className=\"bg-blue-500 text-white p-2 rounded-r text-sm sm:text-base\"\n             disabled={isLoading}\n           >\n             {isLoading ? 'Processing...' : mode === 'text' ? 'Send' : 'Generate'}\n           </button>\n         </form>\n       </div>\n     );\n   }\n   ```\n\n5. Improve the Message component for better mobile display:\n   ```typescript\n   // components/chat/Message.tsx (responsive improvements)\n   export default function Message({ role, content, type, imageUrl }) {\n     return (\n       <div className={`p-3 sm:p-4 mb-2 sm:mb-4 rounded text-sm sm:text-base ${role === 'user' ? 'bg-blue-50' : 'bg-gray-50'}`}>\n         <div className=\"font-bold\">{role === 'user' ? 'You' : 'AI'}</div>\n         <div className=\"mt-1\">\n           {type === 'text' ? (\n             <FormattedMessage content={content} />\n           ) : (\n             <div>\n               {content}\n               {imageUrl && (\n                 <div className=\"mt-2\">\n                   <img \n                     src={imageUrl} \n                     alt=\"Generated image\" \n                     className=\"max-w-full rounded shadow-sm\" \n                     style={{ maxHeight: '60vh' }}\n                   />\n                 </div>\n               )}\n             </div>\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n6. Add meta viewport tag for proper mobile scaling:\n   ```typescript\n   // app/layout.tsx\n   export default function RootLayout({ children }) {\n     return (\n       <html lang=\"en\">\n         <head>\n           <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n           <title>AI Chat</title>\n         </head>\n         <body>{children}</body>\n       </html>\n     );\n   }\n   ```\n\n7. Add media queries for specific device sizes:\n   ```css\n   /* globals.css (additions) */\n   @media (max-width: 640px) {\n     .prose {\n       font-size: 0.875rem;\n     }\n     \n     pre {\n       padding: 0.5rem !important;\n     }\n   }\n   ```",
        "testStrategy": "1. Test layout on various device sizes (mobile, tablet, desktop)\n2. Verify sidebar opens and closes correctly on mobile\n3. Test touch interactions on mobile devices\n4. Validate that content is readable on small screens\n5. Test keyboard accessibility on all screen sizes\n6. Verify that images scale appropriately on different devices",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Supabase Edge Functions for Chat Logic",
        "description": "Create Supabase Edge Functions to handle chat logic and API interactions, providing a serverless backend for the application.",
        "details": "1. Set up Supabase Edge Functions:\n   ```bash\n   # Initialize Edge Functions in your project\n   supabase functions new chat-completion\n   supabase functions new image-generation\n   ```\n\n2. Implement the chat completion Edge Function:\n   ```typescript\n   // supabase/functions/chat-completion/index.ts\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n   import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.2.1';\n   \n   const corsHeaders = {\n     'Access-Control-Allow-Origin': '*',\n     'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n   };\n   \n   serve(async (req) => {\n     // Handle CORS preflight requests\n     if (req.method === 'OPTIONS') {\n       return new Response('ok', { headers: corsHeaders });\n     }\n     \n     try {\n       const { messages, chatId } = await req.json();\n       \n       // Initialize OpenAI\n       const configuration = new Configuration({\n         apiKey: Deno.env.get('OPENAI_API_KEY'),\n       });\n       const openai = new OpenAIApi(configuration);\n       \n       // Create Supabase client\n       const supabaseClient = createClient(\n         Deno.env.get('SUPABASE_URL') ?? '',\n         Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n         {\n           global: {\n             headers: { Authorization: req.headers.get('Authorization')! },\n           },\n         }\n       );\n       \n       // Call OpenAI API\n       const completion = await openai.createChatCompletion({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages,\n         temperature: 0.7,\n         stream: false,\n       });\n       \n       const responseMessage = completion.data.choices[0].message;\n       \n       // Save message to database if chatId is provided\n       if (chatId) {\n         await supabaseClient.from('chat_messages').insert({\n           chat_id: chatId,\n           role: 'assistant',\n           content: responseMessage.content,\n           type: 'text',\n         });\n       }\n       \n       return new Response(JSON.stringify(responseMessage), {\n         headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n       });\n     } catch (error) {\n       console.error('Error:', error);\n       return new Response(JSON.stringify({ error: error.message }), {\n         status: 500,\n         headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n       });\n     }\n   });\n   ```\n\n3. Implement the image generation Edge Function:\n   ```typescript\n   // supabase/functions/image-generation/index.ts\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n   import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.2.1';\n   \n   const corsHeaders = {\n     'Access-Control-Allow-Origin': '*',\n     'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n   };\n   \n   serve(async (req) => {\n     // Handle CORS preflight requests\n     if (req.method === 'OPTIONS') {\n       return new Response('ok', { headers: corsHeaders });\n     }\n     \n     try {\n       const { prompt, chatId } = await req.json();\n       \n       // Initialize OpenAI\n       const configuration = new Configuration({\n         apiKey: Deno.env.get('OPENAI_API_KEY'),\n       });\n       const openai = new OpenAIApi(configuration);\n       \n       // Create Supabase client\n       const supabaseClient = createClient(\n         Deno.env.get('SUPABASE_URL') ?? '',\n         Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n         {\n           global: {\n             headers: { Authorization: req.headers.get('Authorization')! },\n           },\n         }\n       );\n       \n       // Call OpenAI API\n       const response = await openai.createImage({\n         prompt,\n         n: 1,\n         size: '1024x1024',\n       });\n       \n       const imageUrl = response.data.data[0].url;\n       \n       // Save message to database if chatId is provided\n       if (chatId) {\n         await supabaseClient.from('chat_messages').insert({\n           chat_id: chatId,\n           role: 'assistant',\n           content: 'Here\\'s the image you requested:',\n           type: 'image',\n           image_url: imageUrl,\n         });\n       }\n       \n       return new Response(JSON.stringify({ url: imageUrl }), {\n         headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n       });\n     } catch (error) {\n       console.error('Error:', error);\n       return new Response(JSON.stringify({ error: error.message }), {\n         status: 500,\n         headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n       });\n     }\n   });\n   ```\n\n4. Create a client-side utility to call the Edge Functions:\n   ```typescript\n   // lib/edge-functions.ts\n   import { supabase } from './supabase';\n   \n   export async function callChatCompletionFunction(messages, chatId) {\n     const { data, error } = await supabase.functions.invoke('chat-completion', {\n       body: { messages, chatId },\n     });\n     \n     if (error) throw error;\n     return data;\n   }\n   \n   export async function callImageGenerationFunction(prompt, chatId) {\n     const { data, error } = await supabase.functions.invoke('image-generation', {\n       body: { prompt, chatId },\n     });\n     \n     if (error) throw error;\n     return data;\n   }\n   ```\n\n5. Update the ChatInput component to use Edge Functions:\n   ```typescript\n   // components/chat/ChatInput.tsx (updated for Edge Functions)\n   import { callChatCompletionFunction, callImageGenerationFunction } from '@/lib/edge-functions';\n   \n   // Inside handleSubmit function\n   if (mode === 'text') {\n     try {\n       setIsLoading(true);\n       \n       // Format messages for API\n       const formattedMessages = formatChatMessages(messages);\n       \n       // Call Edge Function instead of direct API\n       const response = await callChatCompletionFunction(\n         formattedMessages,\n         currentSessionId\n       );\n       \n       // Add AI response\n       addMessage({\n         role: 'assistant',\n         content: response.content,\n         type: 'text'\n       });\n       \n     } catch (error) {\n       console.error('Error:', error);\n       setLocalError('Failed to generate response. Please try again.');\n     } finally {\n       setIsLoading(false);\n     }\n   } else {\n     // Image mode\n     try {\n       setIsLoading(true);\n       \n       // Call Edge Function for image generation\n       const response = await callImageGenerationFunction(\n         input,\n         currentSessionId\n       );\n       \n       // Add AI response with image\n       addMessage({\n         role: 'assistant',\n         content: 'Here\\'s the image you requested:',\n         type: 'image',\n         imageUrl: response.url\n       });\n       \n     } catch (error) {\n       console.error('Error generating image:', error);\n       setLocalError('Failed to generate image. Please try again.');\n     } finally {\n       setIsLoading(false);\n     }\n   }\n   ```\n\n6. Deploy the Edge Functions:\n   ```bash\n   supabase functions deploy chat-completion\n   supabase functions deploy image-generation\n   ```\n\n7. Set up environment variables for the Edge Functions:\n   ```bash\n   supabase secrets set OPENAI_API_KEY=your_openai_api_key\n   ```",
        "testStrategy": "1. Test Edge Functions locally with the Supabase CLI\n2. Verify chat completion function returns expected responses\n3. Test image generation function with various prompts\n4. Validate database operations work correctly from Edge Functions\n5. Test error handling in Edge Functions\n6. Verify client-side integration with Edge Functions",
        "priority": "medium",
        "dependencies": [
          2,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Optimize API Usage and Implement Rate Limiting",
        "description": "Optimize API calls to OpenAI and implement rate limiting to prevent excessive usage and manage costs effectively.",
        "details": "1. Create a rate limiting utility:\n   ```typescript\n   // lib/rate-limit.ts\n   import { Redis } from '@upstash/redis';\n   \n   // Initialize Redis client (using Upstash Redis or similar)\n   const redis = Redis.fromEnv();\n   \n   export interface RateLimitConfig {\n     limit: number;\n     window: number; // in seconds\n     identifier: string;\n   }\n   \n   export async function rateLimit(config: RateLimitConfig): Promise<{ success: boolean; remaining: number }> {\n     const { limit, window, identifier } = config;\n     const key = `rate-limit:${identifier}`;\n     \n     // Get current count\n     const count = await redis.get<number>(key) || 0;\n     \n     if (count >= limit) {\n       return { success: false, remaining: 0 };\n     }\n     \n     // Increment count\n     const newCount = await redis.incr(key);\n     \n     // Set expiry if this is the first request in the window\n     if (newCount === 1) {\n       await redis.expire(key, window);\n     }\n     \n     return { success: true, remaining: limit - newCount };\n   }\n   ```\n\n2. Install Upstash Redis client:\n   ```bash\n   npm install @upstash/redis\n   ```\n\n3. Apply rate limiting to API routes:\n   ```typescript\n   // app/api/chat/stream/route.ts (with rate limiting)\n   import { rateLimit } from '@/lib/rate-limit';\n   import { getIpAddress } from '@/lib/utils';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       // Get client IP or other identifier\n       const identifier = getIpAddress(req) || 'anonymous';\n       \n       // Apply rate limit (e.g., 10 requests per minute)\n       const rateLimitResult = await rateLimit({\n         limit: 10,\n         window: 60,\n         identifier,\n       });\n       \n       if (!rateLimitResult.success) {\n         return NextResponse.json(\n           { error: 'Rate limit exceeded. Please try again later.' },\n           { status: 429 }\n         );\n       }\n       \n       // Add rate limit headers\n       const headers = {\n         'X-RateLimit-Limit': '10',\n         'X-RateLimit-Remaining': rateLimitResult.remaining.toString(),\n       };\n       \n       // Rest of function\n       // ...\n       \n       // Return response with rate limit headers\n       return new StreamingTextResponse(response.body, { headers });\n     } catch (error) {\n       // Error handling\n     }\n   }\n   ```\n\n4. Create a utility to get client IP address:\n   ```typescript\n   // lib/utils.ts (addition)\n   import { NextRequest } from 'next/server';\n   \n   export function getIpAddress(req: NextRequest): string | null {\n     // Try various headers that might contain the IP\n     const forwardedFor = req.headers.get('x-forwarded-for');\n     if (forwardedFor) {\n       return forwardedFor.split(',')[0].trim();\n     }\n     \n     const realIp = req.headers.get('x-real-ip');\n     if (realIp) {\n       return realIp.trim();\n     }\n     \n     // For local development\n     return '127.0.0.1';\n   }\n   ```\n\n5. Implement token counting to optimize API usage:\n   ```typescript\n   // lib/token-counter.ts\n   import { encode } from 'gpt-tokenizer';\n   \n   export function countTokens(text: string): number {\n     return encode(text).length;\n   }\n   \n   export function estimateTokensForMessages(messages: any[]): number {\n     // Base tokens for the messages format\n     let tokenCount = 3; // Every reply is primed with <|start|>assistant<|message|>\n     \n     for (const message of messages) {\n       // Add tokens for message format\n       tokenCount += 4; // Every message follows <|start|>{role}<|message|>{content}\n       \n       // Add tokens for content\n       if (typeof message.content === 'string') {\n         tokenCount += countTokens(message.content);\n       }\n       \n       // Add tokens for role (usually 'system', 'user', or 'assistant')\n       tokenCount += 1; // Approximate token count for role\n     }\n     \n     return tokenCount;\n   }\n   ```\n\n6. Install token counter:\n   ```bash\n   npm install gpt-tokenizer\n   ```\n\n7. Optimize message history to stay within token limits:\n   ```typescript\n   // lib/message-optimizer.ts\n   import { estimateTokensForMessages } from './token-counter';\n   \n   const MAX_TOKENS = 4000; // Adjust based on model limits\n   \n   export function optimizeMessageHistory(messages: any[], maxTokens = MAX_TOKENS): any[] {\n     // If messages are already within limits, return as is\n     const currentTokens = estimateTokensForMessages(messages);\n     if (currentTokens <= maxTokens) {\n       return messages;\n     }\n     \n     // Keep system messages and recent messages, trim older ones\n     const systemMessages = messages.filter(msg => msg.role === 'system');\n     const nonSystemMessages = messages.filter(msg => msg.role !== 'system');\n     \n     // Always keep the most recent user message\n     const lastUserMessage = nonSystemMessages.filter(msg => msg.role === 'user').pop();\n     \n     // Start with system messages and the last user message\n     let optimizedMessages = [...systemMessages];\n     if (lastUserMessage) {\n       optimizedMessages.push(lastUserMessage);\n     }\n     \n     // Calculate remaining token budget\n     let remainingTokens = maxTokens - estimateTokensForMessages(optimizedMessages);\n     \n     // Add as many recent messages as possible, starting from the most recent\n     const recentMessages = [...nonSystemMessages].reverse();\n     for (const message of recentMessages) {\n       // Skip the last user message as it's already included\n       if (message === lastUserMessage) continue;\n       \n       const messageTokens = estimateTokensForMessages([message]);\n       if (messageTokens <= remainingTokens) {\n         optimizedMessages.unshift(message); // Add to beginning to maintain order\n         remainingTokens -= messageTokens;\n       } else {\n         break;\n       }\n     }\n     \n     return optimizedMessages;\n   }\n   ```\n\n8. Apply message optimization before API calls:\n   ```typescript\n   // app/api/chat/stream/route.ts (with optimization)\n   import { optimizeMessageHistory } from '@/lib/message-optimizer';\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { messages } = await req.json();\n       \n       // Optimize messages to stay within token limits\n       const optimizedMessages = optimizeMessageHistory(messages);\n       \n       const response = await openai.chat.completions.create({\n         model: 'gpt-4.1-nano-2025-04-14',\n         messages: optimizedMessages,\n         temperature: 0.7,\n         stream: true,\n       });\n       \n       // Rest of function\n       // ...\n     } catch (error) {\n       // Error handling\n     }\n   }\n   ```",
        "testStrategy": "1. Test rate limiting with multiple rapid requests\n2. Verify token counting accuracy with various message types\n3. Test message optimization with large conversation histories\n4. Validate that optimized messages maintain conversation context\n5. Test rate limit headers are returned correctly\n6. Verify error handling for rate-limited requests",
        "priority": "low",
        "dependencies": [
          4,
          6,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Cross-Browser Compatibility Testing",
        "description": "Ensure the application works correctly across different browsers and platforms by implementing comprehensive cross-browser testing.",
        "details": "1. Set up cross-browser testing tools:\n   ```bash\n   npm install -D playwright @playwright/test\n   npx playwright install\n   ```\n\n2. Create a basic Playwright configuration:\n   ```typescript\n   // playwright.config.ts\n   import { PlaywrightTestConfig } from '@playwright/test';\n   \n   const config: PlaywrightTestConfig = {\n     testDir: './tests',\n     timeout: 30000,\n     forbidOnly: !!process.env.CI,\n     retries: process.env.CI ? 2 : 0,\n     workers: process.env.CI ? 1 : undefined,\n     reporter: 'html',\n     use: {\n       trace: 'on-first-retry',\n       screenshot: 'only-on-failure',\n     },\n     projects: [\n       {\n         name: 'chromium',\n         use: { browserName: 'chromium' },\n       },\n       {\n         name: 'firefox',\n         use: { browserName: 'firefox' },\n       },\n       {\n         name: 'webkit',\n         use: { browserName: 'webkit' },\n       },\n     ],\n   };\n   \n   export default config;\n   ```\n\n3. Create basic test cases for core functionality:\n   ```typescript\n   // tests/basic.spec.ts\n   import { test, expect } from '@playwright/test';\n   \n   test.describe('Basic functionality', () => {\n     test('should load the application', async ({ page }) => {\n       await page.goto('/');\n       await expect(page).toHaveTitle(/AI Chat/);\n     });\n     \n     test('should send a message and receive a response', async ({ page }) => {\n       await page.goto('/');\n       \n       // Type and send a message\n       await page.fill('input[type=\"text\"]', 'Hello, how are you?');\n       await page.click('button[type=\"submit\"]');\n       \n       // Wait for user message to appear\n       await expect(page.locator('.bg-blue-50')).toContainText('Hello, how are you?');\n       \n       // Wait for AI response (may take time)\n       await expect(page.locator('.bg-gray-50')).toBeVisible({ timeout: 10000 });\n     });\n     \n     test('should toggle between text and image modes', async ({ page }) => {\n       await page.goto('/');\n       \n       // Click image mode button\n       await page.click('button:has-text(\"Image\")');\n       \n       // Verify placeholder text changed\n       await expect(page.locator('input[type=\"text\"]')).toHaveAttribute(\n         'placeholder', \n         /Describe the image/\n       );\n       \n       // Switch back to text mode\n       await page.click('button:has-text(\"Text\")');\n       \n       // Verify placeholder text changed back\n       await expect(page.locator('input[type=\"text\"]')).toHaveAttribute(\n         'placeholder', \n         /Type your message/\n       );\n     });\n   });\n   ```\n\n4. Create tests for responsive design:\n   ```typescript\n   // tests/responsive.spec.ts\n   import { test, expect } from '@playwright/test';\n   \n   test.describe('Responsive design', () => {\n     test('should show sidebar on desktop', async ({ page }) => {\n       // Set desktop viewport\n       await page.setViewportSize({ width: 1280, height: 720 });\n       await page.goto('/');\n       \n       // Sidebar should be visible\n       await expect(page.locator('text=New Chat').first()).toBeVisible();\n     });\n     \n     test('should hide sidebar on mobile', async ({ page }) => {\n       // Set mobile viewport\n       await page.setViewportSize({ width: 375, height: 667 });\n       await page.goto('/');\n       \n       // Sidebar should be hidden\n       await expect(page.locator('.w-64 >> text=New Chat')).not.toBeVisible();\n       \n       // Menu button should be visible\n       await expect(page.locator('button[aria-label=\"Open menu\"]')).toBeVisible();\n     });\n     \n     test('should open sidebar on menu click on mobile', async ({ page }) => {\n       // Set mobile viewport\n       await page.setViewportSize({ width: 375, height: 667 });\n       await page.goto('/');\n       \n       // Click menu button\n       await page.click('button[aria-label=\"Open menu\"]');\n       \n       // Sidebar should become visible\n       await expect(page.locator('text=New Chat').first()).toBeVisible();\n     });\n   });\n   ```\n\n5. Create a manual testing checklist for browsers not covered by automation:\n   ```markdown\n   # Cross-Browser Testing Checklist\n   \n   ## Browsers to Test\n   - Chrome (latest)\n   - Firefox (latest)\n   - Safari (latest)\n   - Edge (latest)\n   - iOS Safari\n   - Android Chrome\n   \n   ## Test Cases\n   \n   ### Basic Functionality\n   - [ ] Application loads correctly\n   - [ ] Can send and receive text messages\n   - [ ] Can toggle between text and image modes\n   - [ ] Can generate images\n   - [ ] Can start a new chat\n   \n   ### UI/Layout\n   - [ ] Layout displays correctly on desktop\n   - [ ] Layout displays correctly on mobile\n   - [ ] Sidebar opens and closes on mobile\n   - [ ] Messages are properly formatted\n   - [ ] Images display correctly\n   \n   ### Performance\n   - [ ] Application loads within acceptable time\n   - [ ] Responses are received within acceptable time\n   - [ ] No visible lag when typing or scrolling\n   \n   ### Accessibility\n   - [ ] Can navigate using keyboard\n   - [ ] Screen readers can access content\n   - [ ] Color contrast is sufficient\n   ```\n\n6. Add browser compatibility polyfills:\n   ```typescript\n   // Install polyfills\n   npm install core-js regenerator-runtime\n   \n   // Add to _app.tsx or layout.tsx\n   import 'core-js/stable';\n   import 'regenerator-runtime/runtime';\n   ```\n\n7. Add CSS vendor prefixes with Autoprefixer (already included with TailwindCSS):\n   ```javascript\n   // postcss.config.js\n   module.exports = {\n     plugins: {\n       tailwindcss: {},\n       autoprefixer: {},\n     },\n   };\n   ```",
        "testStrategy": "1. Run automated tests across Chrome, Firefox, and Safari\n2. Manually test on Edge and mobile browsers\n3. Verify layout consistency across browsers\n4. Test keyboard navigation in all browsers\n5. Validate that streaming works in all supported browsers\n6. Test image generation and display across browsers",
        "priority": "low",
        "dependencies": [
          5,
          6,
          8,
          12
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-23T02:31:32.186Z",
      "updated": "2025-08-23T02:33:01.453Z",
      "description": "Tasks for master context"
    }
  }
}